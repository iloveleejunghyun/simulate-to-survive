# Claude.md - 项目核心理解与开发方案

## 项目概述
- **项目名称**: simulate-to-survive
- **游戏类型**: 文字游戏
- **目标平台**: Steam (PC/Mac/Linux)
- **开发语言**: Python + Pygame
- **项目状态**: 初始规划阶段

## 技术选型分析

### 为什么选择 Python + Pygame？
1. **学习成本低**: Python语法简单，适合初学者
2. **文字处理强大**: 有丰富的文本处理库
3. **快速原型**: 可以快速实现核心玩法
4. **跨平台支持**: 原生支持 Windows/macOS/Linux
5. **Steam发布**: 通过PyInstaller打包后可以发布

### Pygame核心功能
Pygame是一个功能强大的2D游戏开发库，主要功能包括：

#### 显示和图形
- **窗口管理**: 创建、调整、关闭游戏窗口
- **表面(Surface)**: 2D图形绘制的基础
- **精灵(Sprite)**: 游戏对象的图形表示
- **图像处理**: 加载、缩放、旋转图片
- **绘图功能**: 线条、矩形、圆形、多边形等基本图形
- **颜色管理**: RGB、RGBA颜色支持

#### 文字和字体
- **字体渲染**: 支持TTF、OTF字体文件
- **文字显示**: 在屏幕上显示各种样式的文字
- **文字效果**: 颜色、大小、粗体、斜体等
- **多语言支持**: 支持中文、日文等Unicode字符

#### 输入处理
- **键盘输入**: 检测按键按下、释放、持续按下
- **鼠标输入**: 鼠标移动、点击、滚轮
- **游戏手柄**: 支持多种游戏手柄输入
- **触摸输入**: 移动设备触摸支持

#### 音频系统
- **音效播放**: 播放WAV、OGG等格式音效
- **背景音乐**: 循环播放背景音乐
- **音量控制**: 调节音量和静音
- **音频格式**: 支持多种音频格式

#### 时间控制
- **帧率控制**: 控制游戏运行速度
- **定时器**: 创建定时事件
- **时钟管理**: 精确的时间控制

#### 碰撞检测
- **矩形碰撞**: 快速检测矩形重叠
- **圆形碰撞**: 检测圆形碰撞
- **像素碰撞**: 精确的像素级碰撞检测
- **组碰撞**: 批量检测多个对象

#### 数学和物理
- **向量运算**: 2D向量计算
- **三角函数**: 角度和距离计算
- **随机数**: 生成随机数和随机选择

#### 文件和数据
- **文件操作**: 读取配置文件、保存游戏数据
- **JSON支持**: 数据序列化和反序列化
- **图像保存**: 截图和图像保存功能

#### 网络功能
- **基础网络**: 简单的网络通信
- **HTTP请求**: 与服务器通信
- **WebSocket**: 实时网络通信

### Pygame在文字游戏中的应用

#### 核心文字功能
- **文字渲染**: 高质量的文字显示，支持各种字体
- **文字动画**: 打字机效果、淡入淡出、滚动文字
- **文字布局**: 自动换行、对齐、段落间距
- **文字交互**: 点击文字、文字选择、文字输入框

#### 界面设计
- **菜单系统**: 主菜单、设置菜单、游戏内菜单
- **对话框**: 角色对话、系统提示、选择框
- **状态显示**: 生命值、经验值、物品栏等
- **进度条**: 加载进度、技能冷却等

#### 游戏机制支持
- **回合制系统**: 精确的时间控制
- **存档系统**: 游戏进度保存和读取
- **随机事件**: 随机数生成和事件触发
- **音效反馈**: 按键音效、背景音乐

#### 用户体验
- **响应式设计**: 适应不同屏幕尺寸
- **无障碍支持**: 高对比度、字体大小调节
- **多语言**: 支持中英文切换
- **自定义设置**: 音量、字体、颜色主题等
- **Windows**: 原生支持，性能很好
- **macOS**: 原生支持，性能很好  
- **Linux**: 原生支持，性能很好
- **移动端**: 后续可通过Kivy或BeeWare适配

## 移动端开发策略

### 游戏厂商常用方案
1. **统一引擎方案** (最流行)
   - Unity: 一套代码，发布到 PC/Mac/Linux/Android/iOS
   - Unreal Engine: 同样支持多平台
   - Godot: 开源，支持多平台
   - Cocos2d-x: 专门针对移动端优化

2. **Web技术方案**
   - Electron: 可以打包成桌面应用
   - Cordova/PhoneGap: 可以打包成手机应用
   - Progressive Web App (PWA): 网页应用，可以安装到手机

3. **Python的移动端方案**
   - **Kivy** (推荐): 基于Python的跨平台框架，支持Android/iOS
   - **BeeWare**: 将Python代码转换为原生应用
   - **PyQt/PySide**: 可以打包成移动应用，但移动端支持相对较弱

## 开发路线规划

### 第一阶段：桌面版本
```
Python + Pygame → 完成核心游戏逻辑
```
- 搭建基础游戏框架
- 实现核心玩法机制
- 完成游戏内容
- 本地测试和优化

### 第二阶段：移动端适配
```
方案A: 用 Kivy 重写界面层，复用游戏逻辑
方案B: 用 BeeWare 转换整个项目
```
- 评估移动端需求
- 选择合适的适配方案
- 界面适配和优化
- 移动端测试

### 第三阶段：Steam发布
```
PyInstaller 打包 → Steam 发布
```
- 游戏打包和优化
- Steam平台准备
- 发布和营销

## 成功案例参考
- **《文字游戏》(The Textorcist)**: Unity开发，支持PC和移动端
- **《文字地牢》(Text Dungeon)**: 先出PC版，再移植到手机
- **《文字冒险》(Text Adventure)**: 多平台同步发布

## 项目优势
1. **技术门槛低**: Python + Pygame 容易上手
2. **开发速度快**: 文字游戏相对简单，可以快速出原型
3. **成本控制好**: 不需要复杂的图形资源
4. **市场潜力**: Steam上文字游戏有稳定受众
5. **扩展性强**: 后续可以轻松添加新内容

## 风险与挑战
1. **市场竞争**: Steam上文字游戏较多，需要差异化
2. **移动端适配**: 需要额外的开发工作
3. **营销推广**: 独立游戏需要有效的营销策略
4. **用户留存**: 文字游戏需要优秀的剧情和玩法设计

## 测试策略

### 游戏开发中的自动化测试

#### 为什么需要自动化测试？
1. **游戏逻辑复杂**: 文字游戏虽然界面简单，但剧情分支、状态管理可能很复杂
2. **回归测试**: 添加新功能时，确保旧功能不被破坏
3. **跨平台兼容**: 确保在Windows/macOS/Linux上都能正常运行
4. **性能优化**: 检测内存泄漏、性能瓶颈
5. **用户体验**: 确保游戏流程顺畅，没有卡死或崩溃

#### 测试类型和策略

##### 单元测试 (Unit Tests)
- **测试对象**: 游戏逻辑函数、数据模型、工具函数
- **测试工具**: Python的unittest、pytest
- **测试内容**:
  - 游戏状态计算（生命值、经验值等）
  - 物品系统逻辑
  - 存档/读档功能
  - 随机数生成和事件触发
  - 文字处理和格式化

##### 集成测试 (Integration Tests)
- **测试对象**: 模块间的交互、数据流
- **测试内容**:
  - 游戏状态转换
  - 剧情分支选择
  - 存档系统完整性
  - 音效和音乐播放

##### 功能测试 (Functional Tests)
- **测试对象**: 完整的游戏功能
- **测试工具**: 模拟用户操作
- **测试内容**:
  - 完整的游戏流程
  - 菜单导航
  - 设置保存和加载
  - 多语言切换

##### 性能测试 (Performance Tests)
- **测试对象**: 游戏性能指标
- **测试内容**:
  - 内存使用情况
  - 帧率稳定性
  - 加载时间
  - 大文本渲染性能

#### 文字游戏特有的测试需求

##### 剧情和分支测试
- **分支覆盖**: 确保所有剧情分支都能正常触发
- **状态一致性**: 确保玩家选择后游戏状态正确更新
- **存档完整性**: 确保游戏进度能正确保存和恢复

##### 文字显示测试
- **字体渲染**: 不同字体在不同平台上的显示效果
- **多语言支持**: 中英文切换、特殊字符显示
- **文字布局**: 自动换行、对齐、滚动等

##### 用户体验测试
- **响应性**: 按键响应速度
- **可访问性**: 字体大小调节、高对比度模式
- **错误处理**: 异常情况的优雅处理

#### 测试工具推荐

##### Python测试框架
- **pytest**: 功能强大，易于使用
- **unittest**: Python标准库，基础但可靠
- **nose2**: 兼容unittest，功能更丰富

##### 游戏测试工具
- **pygame.test**: Pygame自带的测试工具
- **mock**: 模拟外部依赖
- **coverage**: 代码覆盖率分析

##### 自动化测试工具
- **GitHub Actions**: 持续集成
- **Travis CI**: 跨平台测试
- **AppVeyor**: Windows平台测试

#### 测试策略建议

##### 开发阶段
1. **核心逻辑优先**: 先测试游戏的核心算法和状态管理
2. **增量测试**: 每添加新功能就写对应的测试
3. **重构保护**: 测试确保重构不会破坏现有功能

##### 发布前
1. **完整回归测试**: 运行所有测试用例
2. **跨平台测试**: 在不同操作系统上测试
3. **性能测试**: 确保性能满足要求
4. **用户体验测试**: 手动测试关键流程

##### 维护阶段
1. **持续集成**: 每次代码提交自动运行测试
2. **定期回归**: 定期运行完整测试套件
3. **用户反馈**: 根据用户反馈补充测试用例

## 游戏设计规划

### 游戏概念设计
基于项目名称"simulate-to-survive"，需要确定以下核心要素：

#### 游戏类型
- **生存模拟**: 在特定环境中生存
- **文字冒险**: 基于选择的剧情发展
- **RPG元素**: 角色成长和属性系统
- **策略元素**: 资源管理和决策制定

#### 核心玩法机制
- **生存系统**: 生命值、饥饿度、体力、精神状态
- **时间系统**: 昼夜循环、季节变化、事件触发
- **选择系统**: 玩家决策影响剧情走向
- **资源系统**: 食物、工具、材料收集和管理
- **环境系统**: 天气、地形、危险因素

#### 游戏设定
- **背景故事**: 世界观和背景设定
- **角色系统**: 主角属性和能力
- **环境设定**: 生存场景和挑战
- **目标设定**: 胜利条件和失败条件

#### 技术需求分析
基于游戏设计，确定技术栈和依赖：

##### 核心依赖
- **pygame**: 基础游戏引擎
- **json**: 游戏数据存储
- **random**: 随机事件生成
- **datetime**: 时间系统管理

##### 可选依赖
- **sqlite3**: 复杂数据存储
- **pickle**: 对象序列化
- **configparser**: 配置文件管理
- **logging**: 游戏日志记录

##### 开发工具
- **pytest**: 单元测试
- **black**: 代码格式化
- **flake8**: 代码检查
- **mypy**: 类型检查

### Steam云存档策略

#### 为什么需要考虑Steam云存档？
1. **用户体验**: 玩家可以在不同设备上继续游戏
2. **Steam要求**: Steam平台对云存档有基本要求
3. **竞争优势**: 云存档是Steam游戏的标配功能
4. **数据安全**: 防止本地存档丢失

#### Steam云存档的技术要求

##### 基本要求
- **存档位置**: 必须使用Steam指定的存档目录
- **文件格式**: 支持文本格式（JSON、XML等）
- **文件大小**: 单个存档文件通常限制在100MB以内
- **同步机制**: 需要处理本地和云端的数据同步

##### 存档目录结构
```
Windows: C:\Program Files (x86)\Steam\userdata\[SteamID]\[AppID]\remote\
macOS: ~/Library/Application Support/Steam/userdata/[SteamID]/[AppID]/remote/
Linux: ~/.steam/steam/userdata/[SteamID]/[AppID]/remote/
```

#### 实现策略

##### 方案A: 使用Steamworks SDK (推荐)
- **优点**: 官方支持，功能完整
- **缺点**: 需要C++知识，集成复杂
- **适用**: 大型项目，需要完整Steam功能

##### 方案B: 使用Greenworks (推荐)
- **优点**: Node.js封装，相对简单
- **缺点**: 需要额外学习Node.js
- **适用**: 中等复杂度项目

##### 方案C: 手动实现 (适合文字游戏)
- **优点**: 完全控制，简单直接
- **缺点**: 需要自己处理同步逻辑
- **适用**: 简单的文字游戏

#### 文字游戏的云存档实现

##### 存档数据结构
```json
{
  "game_version": "1.0.0",
  "save_date": "2024-01-01T12:00:00Z",
  "player_data": {
    "name": "玩家名",
    "level": 5,
    "health": 80,
    "hunger": 60,
    "energy": 70
  },
  "game_state": {
    "current_day": 15,
    "location": "森林",
    "inventory": [...],
    "quests": [...]
  },
  "settings": {
    "language": "zh_CN",
    "volume": 0.8,
    "text_speed": "normal"
  }
}
```

##### 实现步骤
1. **检测Steam环境**: 判断是否在Steam中运行
2. **获取存档路径**: 使用Steam API获取正确的存档目录
3. **数据序列化**: 将游戏数据转换为JSON格式
4. **文件操作**: 保存到Steam云存档目录
5. **同步处理**: 处理本地和云端的数据冲突

##### 技术实现
```python
# 伪代码示例
import os
import json
import steamworks

class SteamCloudSave:
    def __init__(self):
        self.steam = steamworks.Steamworks()
        self.save_dir = self.get_steam_save_directory()
    
    def save_game(self, game_data):
        # 保存到Steam云存档
        save_file = os.path.join(self.save_dir, "savegame.json")
        with open(save_file, 'w', encoding='utf-8') as f:
            json.dump(game_data, f, ensure_ascii=False, indent=2)
        
        # 触发Steam云同步
        self.steam.cloud.sync()
    
    def load_game(self):
        # 从Steam云存档加载
        save_file = os.path.join(self.save_dir, "savegame.json")
        if os.path.exists(save_file):
            with open(save_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        return None
```

#### 开发建议

##### 开发阶段
1. **先实现本地存档**: 确保基本存档功能正常
2. **设计通用接口**: 抽象存档接口，便于后续扩展
3. **测试数据格式**: 确保存档数据格式稳定

##### 发布前
1. **集成Steam API**: 添加Steam云存档支持
2. **测试云同步**: 在不同设备上测试存档同步
3. **错误处理**: 处理网络问题和同步冲突

##### 维护阶段
1. **版本兼容**: 确保新版本能读取旧存档
2. **数据迁移**: 处理存档格式升级
3. **用户反馈**: 根据用户反馈优化存档功能

## 下一步行动
1. **确定具体的游戏类型和核心玩法** (当前步骤)
2. 根据游戏设计搭建Python + Pygame开发环境
3. 创建符合游戏需求的基础框架
4. 实现核心游戏机制
5. 建立测试框架和基础测试用例

---
*最后更新: 2024年* 